# ПЕРЕДАЧА КОРТЕЖЕЙ


# def get_error_details():
#     return 2, 'a description the error No2'
#
#
# errnum, errstr = get_error_details()
#
# print(errnum)
# print(errstr)

# Чтобы передать в переменную все оставшиеся значения некоторой последовательности нужно использовать символ "*"

# a, *b = [1, 2, 3, 4]
#
# print(a)
# print(b)

# Быстрая смена значений местами

# a = 5
# b = 6
# a, b = b, a
# print('a -> ', a)
# print('b -> ', b)

# СПЕЦИАЛЬНЫЕ МЕТОДЫ

# Пример специальных методов: __init__, __del__ Они служат для имитации поведения встроенных типов данных

# БЛОКИ В ОДНО ВЫРАЖЕНИЕ

# Является не лучшей практикой!

# flag = True
#
# if flag: print('Yes')

# LAMBDA-ФОРМЫ

# lambda - функция, принимающая параметр за которым следует одно выражение. Это выражение становится телом функции, а
# значение этого выражения возвращается новой функцией

# .sort изменяет исходный список! key - используется для создания своего принципа сортировки

# points = [{'x': 2, 'y': 3}, {'x': 4, 'y': 1}]
# points.sort(key=lambda i: i['y'])
#
# print(points)


# ГЕНЕРАТОР СПИСКОВ

# Генераторы списков служат для создания списков на основе уже существующих.
# Синтаксис: [<operation> for <element> in <original_list> if <condition>] - в результате будет сгенерирован новый
# список элементами которого будет результат выполнения <operation>. Сам <operation> будет выполнен только при
# выполнении условия <condition>. Исходный список не изменяется!

# list_one = [2, 3, 4]
# list_two = [i * 2 for i in list_one if i > 2]
# print(list_two)


# ПЕРЕДАЧА КОРТЕЖЕЙ И СЛОВАРЕЙ В  ФУНКЦИИ

# для передачи кортежей и словарей в функцию используются операторы * и **. Особенно полезно при использовании в
# функциях, принимающих переменное число параметров. При использовании оператора * все доп. параметры рассматриваются
# как элементы кортежа, в случае с оператором **, все доп. параметры рассматриваются как пары "ключ"-"значение"

# def power_sum(power, *args):
#     '''Returns the sum of arguments raised to specified degree'''
#     total = 0
#     for i in args:
#         total += pow(i, power)
#     return total
#
#
# print(power_sum(2, 3, 4))
# print(power_sum(2, 10))


# EXEC И EVAL

# exec выполняет программу из текста

# exec('print("Hello world!")')

# eval может сделать вычисления из строки текста

# print(eval('2 * 3'))


# ОПЕРАТОР ASSERT

# assert служит для проверки утверждений. В случае если утверждение не верно, возбуждается исключение AssertionError
# В большинстве случае заменяется блоком try-except, либо проверкой условий, либо показом сообщения об ошибке и
# корректным завершением программы

# my_list = ['item']
#
# assert len(my_list) >= 1
#
# my_list.pop()
#
# print(my_list)
#
# assert len(my_list) >= 1


# ФУНКЦИЯ REPR

# repr служит для получения строкового представления объекта

# i = []
# i.append('item')
# print(repr(i))


# УПРАВЛЯЮЩИЕ ПОСЛДЕОВАТЕЛЬНОСТИ И НЕОБРАБАТЫВАЕМЫЕ СТРОКИ

# управляющая послдовательность создается символом \. Например \' - экранируюет одинарную кавычку, \n - переводит
# строку, \t - символ табуляции. \ - позволяет перенести строку на другую физическую строку, при этом логическая строка
# остается целой.
# В случае когда управляющая последоавтельность в строке должна быть расценена как часть строки, используется оператор
# "r". Оператор r следует всегда использовать с регулярными выражениями во избежании экранирования символов

print(r"This is string without braking the line \n")
